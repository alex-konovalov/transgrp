<html><head><title>[transgrp] 1 The Library of Transitive Groups</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href = "theindex.htm">Index</a>]
<h1>1 The Library of Transitive Groups</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP001.htm#SECT001">Transitive Permutation Groups</a>
<li> <A HREF="CHAP001.htm#SECT002">Selection Functions</a>
</ol><p>
<p>
The Transitive Groups Library is copyright by Alexander Hulpke.
You are free to distribute it, provided that you make no
modifications nor remove this copyright notice.
<p>
<p>
<h2><a name="SECT001">1.1 Transitive Permutation Groups</a></h2>
<p><p>
The transitive groups library currently contains representatives for all
transitive permutation groups of degree at most  30.
Two permutations groups of the same degree are considered to be
equivalent, if there is a renumbering of points, which maps one group into
the other one.
In other words, if they lie in the same conjugacy class under operation
of the full symmetric group by conjugation.
<p>
<a name = "SSEC001.1"></a>
<li><code>TransitiveGroupsAvailable( </code><var>deg</var><code> ) F</code>
<p>
returns whether the transitive groups groups of degree <var>deg</var> are available
for use. This function should be used to test for the scope of the library
available.
<p>
<a name = "SSEC001.2"></a>
<li><code>TransitiveGroup( </code><var>deg</var><code>, </code><var>nr</var><code> ) F</code>
<p>
returns the <var>nr</var>-th transitive  group of degree <var>deg</var>.  Both  <var>deg</var> and
<var>nr</var> must be  positive integers. The transitive groups of equal  degree
are  sorted with  respect to   their  size, so for  example
<code>TransitiveGroup(  </code><var>deg</var><code>, 1 )</code> is a  transitive group  of degree and
size <var>deg</var>, e.g, the cyclic  group  of size <var>deg</var>,   if <var>deg</var> is a
prime.
<p>
<a name = "SSEC001.3"></a>
<li><code>NrTransitiveGroups( </code><var>deg</var><code> ) F</code>
<p>
returns the number of transitive groups of degree <var>deg</var> stored in the
library of transitive groups. The function returns <code>fail</code> if <var>deg</var> is
beyond the range of the library.
<p>
This library was computed by  Gregory Butler, John McKay, Gordon Royle
and Alexander Hulpke.  The list of transitive  groups up  to degree 11
was published in <a href="biblio.htm#BM83"><cite>BM83</cite></a>,  the list of degree  12 was published in
<a href="biblio.htm#Roy87"><cite>Roy87</cite></a>, degree 14 and  15 were published in  <a href="biblio.htm#Butler93"><cite>Butler93</cite></a> and
degrees 16--30 were published in <a href="biblio.htm#Hulpke96"><cite>Hulpke96</cite></a> and <a href="biblio.htm#HulpkeTG"><cite>HulpkeTG</cite></a>.
(Groups of prime degree of course are
primitive and were known long before.)
<p>
The arrangement and the names of the groups of degree up to 15 is the same
as given in <a href="biblio.htm#ConwayHulpkeMcKay98"><cite>ConwayHulpkeMcKay98</cite></a>. With the exception of the symmetric
and alternating group (which are represented as <code>SymmetricGroup</code> and
<code>AlternatingGroup</code>) the generators for these groups also conform to this
paper with the only difference that 0 (which is not permitted in <font face="Gill Sans,Helvetica,Arial">GAP</font> for
permutations to act on) is always replaced by the degree.
<p>
<pre>
gap&gt; TransitiveGroup(10,22);
S(5)[x]2
gap&gt; l:=AllTransitiveGroups(NrMovedPoints,12,Size,1440,IsSolvable,false);
[ S(6)[x]2, M_10.2(12)=A_6.E_4(12)=[S_6[1/720]{M_10}S_6]2 ]
gap&gt; List(l,IsSolvable);
[ false, false ]
</pre>
<p>
<a name = "SSEC001.4"></a>
<li><code>TransitiveIdentification( </code><var>G</var><code> ) A</code>
<p>
Let <var>G</var> be a permutation group, acting transitively on a set  of up to 30
points.  Then <code>TransitiveIdentification</code> will return the position of this
group in the transitive  groups library.  This means,  if <var>G</var> acts on
<var>m</var> points and    <code>TransitiveIdentification</code>  returns <var>n</var>,  then <var>G</var>   is
permutation isomorphic to the group <code>TransitiveGroup(m,n)</code>.
<p>
Note: The points moved do <strong>not</strong> need to be [1..<var>n</var>], the group
<var>langle(2,3,4),(2,3)rangle</var> is considered to be transitive on 3
points. If the group has several orbits on the points moved by it the
result of <code>TransitiveIdentification</code> is undefined.
<p>
<pre>
gap&gt; TransitiveIdentification(Group((1,2),(1,2,3)));
2
</pre>
<p>
<p>
<h2><a name="SECT002">1.2 Selection Functions</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>AllTransitiveGroups( </code><var>fun1</var><code>, </code><var>val1</var><code>, ... ) F</code>
<a name = "SSEC002.1"></a>
<li><code>OneTransitiveGroup( </code><var>fun1</var><code>, </code><var>val1</var><code>, ... ) F</code>
<p>
These functions take an arbitrary number of pairs (but at least one pair)
of arguments. The first argument in such a pair is a function that can be
applied to the groups in the library, and the second argument is either a
single value that this function must return in order to have  this  group
included in the selection, or a list of such  values. 
It returns all (ore one) group satisfying the parameters:
<p>
<pre>
gap&gt; AllTransitiveGroups(NrMovedPoints,[10..15],
&gt;                        Size,         [1..100],
&gt;                        IsAbelian,    false    );
</pre>
<p>
returns a list of all transitive groups with degree between 10 and 15 and
size less than 100 that are not abelian.
<p>
Thus  the <code>AllTransitiveGroups</code>  behaves  as if   it was implemented  by a
function similar to the one defined below, where <code>TransitiveGroupsList</code> is a
list of all transitive groups.  (Note that in  the definition below we assume
for simplicity that <code>AllTransitiveGroups</code> accepts exactly 4 arguments.  It is
of course  obvious how to change this  definition so that the function would
accept a variable number of arguments.)
<p>
<pre>
AllTransitiveGroups := function( fun1, val1, fun2, val2 )
local    groups, g, i;
  groups := [];
  for i  in [ 1 .. Length( TransitiveGroupsList ) ] do
    g := TransitiveGroupsList[i];
    if      fun1(g) = val1  or IsList(val1) and fun1(g) in val1
        and fun2(g) = val2  or IsList(val2) and fun2(g) in val2
     then
      Add( groups, g );
    fi;
  od;
  return groups;
end;
</pre>
Note that the real  selection functions are considerably  more difficult,
to improve the efficiency. Most  important, each recognizes a certain set
of properties which are precomputed for the library without having to
compute them anew for each group. This will substantially speed up the
selection process.
<p>
The selection functions for the transitive
groups library are <code>AllTransitiveGroups</code> and <code>OneTransitiveGroup</code>. They
obtain the following properties from the database without having to compute
them anew:
<p>
<code>NrMovedPoints</code>, <code>Size</code>,   <code>Transitivity</code>, and <code>IsPrimitive</code>.
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>transgrp manual<br>June 2016
</address></body></html>